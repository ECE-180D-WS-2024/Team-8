Previous edits used in Player Class
        # if pressed[pygame.K_e] and pygame.time.get_ticks() - self.time > 300:
        #     self.time = pygame.time.get_ticks()
        #     self.game.object_manager.interact()
        # if self.is_hovering_over_item:  # You need to implement is_hovering_over_item
        #     command = self.speech_instance.listen_for_commands() 
        #     if command == "pick up" and pygame.time.get_ticks() - self.time > 300:
        #         self.time = pygame.time.get_ticks()
        #         self.game.object_manager.interact()

Attempts in Speech Class
import threading
import speech_recognition as sr
# import time

class Speech:
    def __init__(self, callback=None):
        self.recognizer = sr.Recognizer()
        self.microphone = sr.Microphone()
        self.callback = callback
        self.listening = False
        self.thread = None
        self.stop_event = threading.Event()
        self.last_command = None

    def _listen(self):
        # print("Starting speech recognition...")
        #command_recognized = False
        # attempts = 0
        # max_attempts = 1
        # while attempts < max_attempts and not command_recognized and not self.stop_event.is_set():
        #     attempts += 1
        with self.microphone as source:
            self.recognizer.adjust_for_ambient_noise(source)
            try:
                print("Say Command")
                audio = self.recognizer.listen(source, timeout=1, phrase_time_limit=3)
                command = self.recognizer.recognize_google(audio).lower()
                print(f"Recognized: {command}")
                if self.pickup_command(command):
                    print("speech command recognized")
                    if self.callback:
                        self.callback(command)
                    #command_recognized = True
                    #break
                else:
                    print("Recognition Failed. Press e and try again.")
            except sr.RequestError as e:
                # Handle request error, log, or retry logic
                print(f"API unavailable, {e}")
                # if attempts == max_attempts:
                #     print("Failed to recognize after all attempts")
                #break
            except sr.UnknownValueError as e:
                # Handle unknown value error, log, or retry logic
                print(f"Could not understand audio {e}")
                # if attempts == max_attempts:
                #     print("Failed to recognize after all attempts")
            except Exception as e:
                print(f"An unexpected error occurred: {e}")
                #if attempts == max_attempts:
                #    print("Failed to recognize after all attempts")
                #break
    #if not command_recognized:
        #print("Failed to recognize. Press e to try again.")
    #else:
        #pass
        self.listening = False
        self.stop_event.set()
        if self.listening == False:
            print("Thread Stopped")
    #     time.sleep(1)

    def toggle_listening(self):
        """Toggle the listening state and manage the listening thread accordingly."""
        if not self.listening:
            print("Starting speech recognition thread...")
            self.listening = True
            self.stop_event.clear()
            self.thread = threading.Thread(target=self._listen)
            self.thread.start()
        else:
            print("Stopping speech recognition thread...")
            self.listening = False
            self.stop_event.set()
            self.thread.join()
            self.thread = None
    
    def pickup_command(self, command):
        if command == "pick up":
            self.last_command = command
            return True
        return False
    
    def get_last_command(self):
        command = self.last_command
        self.last_command = None
        return command
